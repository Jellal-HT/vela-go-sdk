/*
Generated by cue.

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: no version
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package apply_app

import (
"encoding/json"

"github.com/oam-dev/kubevela-core-api/apis/core.oam.dev/common"
"github.com/oam-dev/kubevela-core-api/apis/core.oam.dev/v1beta1"
"github.com/oam-dev/kubevela-core-api/pkg/oam/util"

"github.com/chivalryq/vela-go-sdk/pkg/apis"
"github.com/chivalryq/vela-go-sdk/pkg/apis/utils"
sdkcommon "github.com/chivalryq/vela-go-sdk/pkg/apis/common"
    "fmt"
)


// ApplyAppSpec - struct for ApplyAppSpec
type ApplyAppSpec struct {
	MapmapOfStringinterface{} *map[string]interface{}
}

// map[string]interface{}AsApplyAppSpec is a convenience function that returns map[string]interface{} wrapped in ApplyAppSpec
func MapmapOfStringinterface{}AsApplyAppSpec(v *map[string]interface{}) ApplyAppSpec {
	return ApplyAppSpec{
		MapmapOfStringinterface{}: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *ApplyAppSpec) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into MapmapOfStringinterface{}
	err = utils.NewStrictDecoder(data).Decode(&dst.MapmapOfStringinterface{})
	if err == nil {
		jsonMapmapOfStringinterface{}, _ := json.Marshal(dst.MapmapOfStringinterface{})
		if string(jsonMapmapOfStringinterface{}) == "{}" { // empty struct
			dst.MapmapOfStringinterface{} = nil
		} else {
			match++
		}
	} else {
		dst.MapmapOfStringinterface{} = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.MapmapOfStringinterface{} = nil

		return fmt.Errorf("data matches more than one schema in oneOf(ApplyAppSpec)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(ApplyAppSpec)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ApplyAppSpec) MarshalJSON() ([]byte, error) {
	if src.MapmapOfStringinterface{} != nil {
		return json.Marshal(&src.MapmapOfStringinterface{})
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ApplyAppSpec) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.MapmapOfStringinterface{} != nil {
		return obj.MapmapOfStringinterface{}
	}

	// all schemas are nil
	return nil
}

type NullableApplyAppSpec struct {
	value *ApplyAppSpec
	isSet bool
}

func (v NullableApplyAppSpec) Get() *ApplyAppSpec {
	return v.value
}

func (v *NullableApplyAppSpec) Set(val *ApplyAppSpec) {
	v.value = val
	v.isSet = true
}

func (v NullableApplyAppSpec) IsSet() bool {
	return v.isSet
}

func (v *NullableApplyAppSpec) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableApplyAppSpec(val *ApplyAppSpec) *NullableApplyAppSpec {
	return &NullableApplyAppSpec{value: val, isSet: true}
}

func (v NullableApplyAppSpec) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableApplyAppSpec) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


const ApplyAppType = "apply-app"

func init() {
	sdkcommon.RegisterWorkflowStep(ApplyAppType, FromWorkflowStep)
	sdkcommon.RegisterWorkflowSubStep(ApplyAppType, FromWorkflowSubStep)
}

type ApplyAppWorkflowStep struct {
	Base       apis.WorkflowStepBase
	Properties ApplyAppSpec
}

func ApplyApp(name string) *ApplyAppWorkflowStep {
	a := &ApplyAppWorkflowStep{Base: apis.WorkflowStepBase{
		Name: name,
		Type: ApplyAppType,
	}}
	return a
}

func (a *ApplyAppWorkflowStep) Build() v1beta1.WorkflowStep {
	_subSteps := make([]v1beta1.WorkflowStep, 0)
	for _, subStep := range a.Base.SubSteps {
		_subSteps = append(_subSteps, subStep.Build())
	}
	subSteps := make([]common.WorkflowSubStep, 0)
	for _, _s := range _subSteps {
		subSteps = append(subSteps, common.WorkflowSubStep{Name: _s.Name, DependsOn: _s.DependsOn, Inputs: _s.Inputs, Outputs: _s.Outputs, If: _s.If, Timeout: _s.Timeout, Meta: _s.Meta, Properties: _s.Properties, Type: _s.Type})
	}
	res := v1beta1.WorkflowStep{
		DependsOn:  a.Base.DependsOn,
		If:         a.Base.If,
		Inputs:     a.Base.Inputs,
		Meta:       a.Base.Meta,
		Name:       a.Base.Name,
		Outputs:    a.Base.Outputs,
		Properties: util.Object2RawExtension(a.Properties),
		SubSteps:   subSteps,
		Timeout:    a.Base.Timeout,
		Type:       ApplyAppType,
	}
	return res
}

func (a *ApplyAppWorkflowStep) FromWorkflowStep(from v1beta1.WorkflowStep) (*ApplyAppWorkflowStep, error) {
	var properties ApplyAppSpec
	if from.Properties != nil {
		err := json.Unmarshal(from.Properties.Raw, &properties)
		if err != nil {
			return nil, err
		}
	}
	subSteps := make([]apis.WorkflowStep, 0)
	for _, _s := range from.SubSteps {
		subStep, err := a.FromWorkflowSubStep(_s)
		if err != nil {
			return nil, err
		}
		subSteps = append(subSteps, subStep)
	}
	a.Base.Name = from.Name
	a.Base.DependsOn = from.DependsOn
	a.Base.Inputs = from.Inputs
	a.Base.Outputs = from.Outputs
	a.Base.If = from.If
	a.Base.Timeout = from.Timeout
	a.Base.Meta = from.Meta
	a.Base.Type = ApplyAppType
	a.Properties = properties
	a.Base.SubSteps = subSteps
	return a, nil
}

func FromWorkflowStep(from v1beta1.WorkflowStep) (apis.WorkflowStep, error) {
	a := &ApplyAppWorkflowStep{}
	return a.FromWorkflowStep(from)
}

func (a *ApplyAppWorkflowStep) FromWorkflowSubStep(from common.WorkflowSubStep) (*ApplyAppWorkflowStep, error) {
	var properties ApplyAppSpec
	if from.Properties != nil {
		err := json.Unmarshal(from.Properties.Raw, &properties)
		if err != nil {
			return nil, err
		}
	}
	a.Base.Name = from.Name
	a.Base.DependsOn = from.DependsOn
	a.Base.Inputs = from.Inputs
	a.Base.Outputs = from.Outputs
	a.Base.If = from.If
	a.Base.Timeout = from.Timeout
	a.Base.Meta = from.Meta
	a.Base.Type = ApplyAppType
	a.Properties = properties
	return a, nil
}

func FromWorkflowSubStep(from common.WorkflowSubStep) (apis.WorkflowStep, error) {
	a := &ApplyAppWorkflowStep{}
	return a.FromWorkflowSubStep(from)
}

func (a *ApplyAppWorkflowStep) WorkflowStepName() string {
	return a.Base.Name
}

func (a *ApplyAppWorkflowStep) DefType() string {
	return ApplyAppType
}



func (a *ApplyAppWorkflowStep) If(_if string) *ApplyAppWorkflowStep {
	a.Base.If = _if
	return a
}

func (a *ApplyAppWorkflowStep) Alias(alias string) *ApplyAppWorkflowStep {
	a.Base.Meta.Alias = alias
	return a
}

func (a *ApplyAppWorkflowStep) Timeout(timeout string) *ApplyAppWorkflowStep {
	a.Base.Timeout = timeout
	return a
}

func (a *ApplyAppWorkflowStep) DependsOn(dependsOn []string) *ApplyAppWorkflowStep {
	a.Base.DependsOn = dependsOn
	return a
}

func (a *ApplyAppWorkflowStep) Inputs(input common.StepInputs) *ApplyAppWorkflowStep {
	a.Base.Inputs = input
	return a
}

func (a *ApplyAppWorkflowStep) Outputs(output common.StepOutputs) *ApplyAppWorkflowStep {
	a.Base.Outputs = output
	return a
}



